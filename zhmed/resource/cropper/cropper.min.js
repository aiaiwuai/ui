!function (t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : "object" == typeof exports ? t(require("jquery")) : t(jQuery)
}(function (x) {
    "use strict";
    var s = x(window), a = x(document), e = window.location, t = window.navigator, n = window.ArrayBuffer,
        r = window.Uint8Array, d = window.DataView, l = window.btoa, o = 0, c = "cropper", p = "cropper-modal",
        h = "cropper-hide", $ = "cropper-hidden", g = "cropper-move", u = "cropper-crop", i = "cropper-disabled",
        f = "mousedown touchstart pointerdown MSPointerDown", m = "mousemove touchmove pointermove MSPointerMove",
        v = "mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel",
        w = "wheel mousewheel DOMMouseScroll", b = "dblclick", C = "load." + c, B = "error." + c, y = "resize." + c,
        D = "build." + c, k = "built." + c, T = "cropstart." + c, L = "cropmove." + c, X = "cropend." + c,
        Y = "crop." + c, M = "zoom." + c, W = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/, z = /^data\:/,
        H = /^data\:([^\;]+)\;base64,/, R = /^data\:image\/jpeg.*;base64,/, O = "preview", E = "action", P = "se",
        U = "sw", I = "ne", F = "nw", j = "all", A = "crop", S = "move", N = "zoom",
        _ = x.isFunction(x("<canvas>")[0].getContext),
        q = t && /safari/i.test(t.userAgent) && /apple computer/i.test(t.vendor), Z = Number, K = Math.min,
        Q = Math.max, V = Math.abs, G = Math.sin, J = Math.cos, tt = Math.sqrt, it = Math.round, et = Math.floor,
        st = String.fromCharCode;

    function at(t) {
        return "number" == typeof t && !isNaN(t)
    }

    function ot(t) {
        return void 0 === t
    }

    function ht(t, i) {
        var e = [];
        return at(i) && e.push(i), e.slice.apply(t, e)
    }

    function nt(t, i) {
        var e = ht(arguments, 2);
        return function () {
            return t.apply(i, e.concat(ht(arguments)))
        }
    }

    function rt(t) {
        var i = t.match(/^(https?:)\/\/([^\:\/\?#]+):?(\d*)/i);
        return i && (i[1] !== e.protocol || i[2] !== e.hostname || i[3] !== e.port)
    }

    function lt(t) {
        var i = "timestamp=" + (new Date).getTime();
        return t + (-1 === t.indexOf("?") ? "?" : "&") + i
    }

    function ct(t) {
        return t ? ' crossOrigin="' + t + '"' : ""
    }

    function pt(t) {
        var i = [], e = t.rotate, s = t.scaleX, a = t.scaleY;
        return at(s) && at(a) && i.push("scale(" + s + "," + a + ")"), at(e) && i.push("rotate(" + e + "deg)"), i.length ? i.join(" ") : "none"
    }

    function dt(t, i) {
        var e, s, a = V(t.degree) % 180, o = (90 < a ? 180 - a : a) * Math.PI / 180, h = G(o), n = J(o), r = t.width,
            l = t.height, c = t.aspectRatio;
        return s = i ? (e = r / (n + h / c)) / c : (e = r * n + l * h, r * h + l * n), {width: e, height: s}
    }

    function gt(t, i) {
        var e, s, a, o = x("<canvas>")[0], h = o.getContext("2d"), n = 0, r = 0, l = i.naturalWidth,
            c = i.naturalHeight, p = i.rotate, d = i.scaleX, g = i.scaleY, u = at(d) && at(g) && (1 !== d || 1 !== g),
            f = at(p) && 0 !== p, m = f || u, v = l * V(d || 1), w = c * V(g || 1);
        return u && (e = v / 2, s = w / 2), f && (e = (v = (a = dt({
            width: v,
            height: w,
            degree: p
        })).width) / 2, s = (w = a.height) / 2), o.width = v, o.height = w, m && (n = -l / 2, r = -c / 2, h.save(), h.translate(e, s)), f && h.rotate(p * Math.PI / 180), u && h.scale(d, g), h.drawImage(t, et(n), et(r), et(l), et(c)), m && h.restore(), o
    }

    function ut(t) {
        var i, e, s, a, o, h, n, r, l, c = new d(t), p = c.byteLength;
        if (255 === c.getUint8(0) && 216 === c.getUint8(1)) for (r = 2; r < p;) {
            if (255 === c.getUint8(r) && 225 === c.getUint8(r + 1)) {
                h = r;
                break
            }
            r++
        }
        if (h && (e = h + 10, "Exif" === function (t, i, e) {
            var s, a = "";
            for (e += s = i; s < e; s++) a += st(t.getUint8(s));
            return a
        }(c, h + 4, 4) && ((a = 18761 === (o = c.getUint16(e))) || 19789 === o) && 42 === c.getUint16(e + 2, a) && 8 <= (s = c.getUint32(e + 4, a)) && (n = e + s)), n) for (p = c.getUint16(n, a), l = 0; l < p; l++) if (r = n + 12 * l + 2, 274 === c.getUint16(r, a)) {
            r += 8, i = c.getUint16(r, a), q && c.setUint16(r, 1, a);
            break
        }
        return i
    }

    function ft(t, i) {
        this.$element = x(t), this.options = x.extend({}, ft.DEFAULTS, x.isPlainObject(i) && i), this.isLoaded = !1, this.isBuilt = !1, this.isCompleted = !1, this.isRotated = !1, this.isCropped = !1, this.isDisabled = !1, this.isReplaced = !1, this.isLimited = !1, this.wheeling = !1, this.isImg = !1, this.originalUrl = "", this.canvas = null, this.cropBox = null, this.zoomcallback = null, this.movecallback = null, this.handler = null, this.init()
    }

    ft.prototype = {
        constructor: ft, init: function () {
            var t, i = this.$element;
            if (i.is("img")) {
                if (this.isImg = !0, this.originalUrl = t = i.attr("src"), !t) return;
                t = i.prop("src")
            } else i.is("canvas") && _ && (t = i[0].toDataURL());
            this.load(t)
        }, trigger: function (t, i) {
            var e = x.Event(t, i);
            return this.$element.trigger(e), e
        }, load: function (t) {
            var i, e, s = this.options, a = this.$element;
            if (t && (a.one(D, s.build), !this.trigger(D).isDefaultPrevented())) {
                if (this.url = t, this.image = {}, !s.checkOrientation || !n) return this.clone();
                if (i = x.proxy(this.read, this), z.test(t)) return R.test(t) ? i(function (t) {
                    var i, e = t.replace(H, ""), s = atob(e), a = s.length, o = new n(a), h = new r(o);
                    for (i = 0; i < a; i++) h[i] = s.charCodeAt(i);
                    return o
                }(t)) : this.clone();
                (e = new XMLHttpRequest).onerror = e.onabort = x.proxy(function () {
                    this.clone()
                }, this), e.onload = function () {
                    i(this.response)
                }, s.checkCrossOrigin && rt(t) && a.prop("crossOrigin") && (t = lt(t)), e.open("get", t), e.responseType = "arraybuffer", e.send()
            }
        }, read: function (t) {
            var i, e, s, a = this.options, o = ut(t), h = this.image;
            if (1 < o) switch (this.url = function (t) {
                var i, e = new r(t), s = e.length, a = "";
                for (i = 0; i < s; i++) a += st(e[i]);
                return "data:image/jpeg;base64," + l(a)
            }(t), o) {
                case 2:
                    e = -1;
                    break;
                case 3:
                    i = -180;
                    break;
                case 4:
                    s = -1;
                    break;
                case 5:
                    i = 90, s = -1;
                    break;
                case 6:
                    i = 90;
                    break;
                case 7:
                    i = 90, e = -1;
                    break;
                case 8:
                    i = -90
            }
            a.rotatable && (h.rotate = i), a.scalable && (h.scaleX = e, h.scaleY = s), this.clone()
        }, clone: function () {
            var t, i, e = this.options, s = this.$element, a = this.url, o = "";
            e.checkCrossOrigin && rt(a) && (t = (o = s.prop("crossOrigin")) ? a : (o = "anonymous", lt(a))), this.crossOrigin = o, this.crossOriginUrl = t, this.$clone = i = x("<img" + ct(o) + ' src="' + (t || a) + '">'), this.isImg ? s[0].complete ? this.start() : s.one(C, x.proxy(this.start, this)) : i.one(C, x.proxy(this.start, this)).one(B, x.proxy(this.stop, this)).addClass(h).insertAfter(s)
        }, start: function () {
            var t = this.$element, i = this.$clone;
            this.isImg || (i.off(B, this.stop), t = i), function (t, i) {
                var e;
                if (t.naturalWidth && !q) return i(t.naturalWidth, t.naturalHeight);
                (e = document.createElement("img")).onload = function () {
                    i(this.width, this.height)
                }, e.src = t.src
            }(t[0], x.proxy(function (t, i) {
                x.extend(this.image, {
                    naturalWidth: t,
                    naturalHeight: i,
                    aspectRatio: t / i
                }), this.isLoaded = !0, this.build()
            }, this))
        }, stop: function () {
            this.$clone.remove(), this.$clone = null
        }, build: function () {
            var t, i, e, s = this.options, a = this.$element, o = this.$clone;
            this.isLoaded && (this.isBuilt && this.unbuild(), this.$container = a.parent(), this.$cropper = t = x(ft.TEMPLATE), this.$canvas = t.find(".cropper-canvas").append(o), this.$dragBox = t.find(".cropper-drag-box"), this.$cropBox = i = t.find(".cropper-crop-box"), this.$viewBox = t.find(".cropper-view-box"), this.$face = e = i.find(".cropper-face"), a.addClass($).after(t), this.isImg || o.removeClass(h), this.initPreview(), this.bind(), s.aspectRatio = Q(0, s.aspectRatio) || NaN, s.viewMode = Q(0, K(3, it(s.viewMode))) || 0, s.autoCrop ? (this.isCropped = !0, s.modal && this.$dragBox.addClass(p)) : i.addClass($), s.guides || i.find(".cropper-dashed").addClass($), s.center || i.find(".cropper-center").addClass($), s.cropBoxMovable && e.addClass(g).data(E, j), s.highlight || e.addClass("cropper-invisible"), s.background && t.addClass("cropper-bg"), s.cropBoxResizable || i.find(".cropper-line, .cropper-point").addClass($), this.setDragMode(s.dragMode), this.render(), this.isBuilt = !0, this.setData(s.data), a.one(k, s.built), setTimeout(x.proxy(function () {
                this.trigger(k), this.isCompleted = !0
            }, this), 0))
        }, unbuild: function () {
            this.isBuilt && (this.isBuilt = !1, this.isCompleted = !1, this.initialImage = null, this.initialCanvas = null, this.initialCropBox = null, this.container = null, this.canvas = null, this.cropBox = null, this.unbind(), this.resetPreview(), this.$preview = null, this.$viewBox = null, this.$cropBox = null, this.$dragBox = null, this.$canvas = null, this.$container = null, this.$cropper.remove(), this.$cropper = null)
        }, render: function () {
            this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.isCropped && this.renderCropBox()
        }, initContainer: function () {
            var t = this.options, i = this.$element, e = this.$container, s = this.$cropper;
            s.addClass($), i.removeClass($), s.css(this.container = {
                width: Q(e.width(), Z(t.minContainerWidth) || 200),
                height: Q(e.height(), Z(t.minContainerHeight) || 100)
            }), i.addClass($), s.removeClass($)
        }, initCanvas: function () {
            var t, i = this.options.viewMode, e = this.container, s = e.width, a = e.height, o = this.image,
                h = o.naturalWidth, n = o.naturalHeight, r = 90 === V(o.rotate), l = r ? n : h, c = r ? h : n,
                p = l / c, d = s, g = a;
            s < a * p ? 3 === i ? d = a * p : g = s / p : 3 === i ? g = s / p : d = a * p, (t = {
                naturalWidth: l,
                naturalHeight: c,
                aspectRatio: p,
                width: d,
                height: g
            }).oldLeft = t.left = (s - d) / 2, t.oldTop = t.top = (a - g) / 2, this.canvas = t, this.isLimited = 1 === i || 2 === i, this.limitCanvas(!0, !0), this.initialImage = x.extend({}, o), this.initialCanvas = x.extend({}, t)
        }, limitCanvas: function (t, i) {
            var e, s, a, o, h = this.options, n = h.viewMode, r = this.container, l = r.width, c = r.height,
                p = this.canvas, d = p.aspectRatio, g = this.cropBox, u = this.isCropped && g;
            t && (e = Z(h.minCanvasWidth) || 0, s = Z(h.minCanvasHeight) || 0, n && (1 < n ? (e = Q(e, l), s = Q(s, c), 3 === n && (e < s * d ? e = s * d : s = e / d)) : e ? e = Q(e, u ? g.width : 0) : s ? s = Q(s, u ? g.height : 0) : u && ((e = g.width) < (s = g.height) * d ? e = s * d : s = e / d)), e && s ? e < s * d ? s = e / d : e = s * d : e ? s = e / d : s && (e = s * d), p.minWidth = e, p.minHeight = s, p.maxWidth = 1 / 0, p.maxHeight = 1 / 0), i && (n ? (a = l - p.width, o = c - p.height, p.minLeft = K(0, a), p.minTop = K(0, o), p.maxLeft = Q(0, a), p.maxTop = Q(0, o), u && this.isLimited && (p.minLeft = K(g.left, g.left + g.width - p.width), p.minTop = K(g.top, g.top + g.height - p.height), p.maxLeft = g.left, p.maxTop = g.top, 2 === n && (p.width >= l && (p.minLeft = K(0, a), p.maxLeft = Q(0, a)), p.height >= c && (p.minTop = K(0, o), p.maxTop = Q(0, o))))) : (p.minLeft = -p.width, p.minTop = -p.height, p.maxLeft = l, p.maxTop = c))
        }, renderCanvas: function (t) {
            var i, e, s = this.canvas, a = this.image, o = a.rotate, h = a.naturalWidth, n = a.naturalHeight;
            this.isRotated && (this.isRotated = !1, (i = (e = dt({
                width: a.width,
                height: a.height,
                degree: o
            })).width / e.height) !== s.aspectRatio && (s.left -= (e.width - s.width) / 2, s.top -= (e.height - s.height) / 2, s.width = e.width, s.height = e.height, s.aspectRatio = i, s.naturalWidth = h, s.naturalHeight = n, o % 180 && (e = dt({
                width: h,
                height: n,
                degree: o
            }), s.naturalWidth = e.width, s.naturalHeight = e.height), this.limitCanvas(!0, !1))), (s.width > s.maxWidth || s.width < s.minWidth) && (s.left = s.oldLeft), (s.height > s.maxHeight || s.height < s.minHeight) && (s.top = s.oldTop), s.width = K(Q(s.width, s.minWidth), s.maxWidth), s.height = K(Q(s.height, s.minHeight), s.maxHeight), this.limitCanvas(!1, !0), s.oldLeft = s.left = K(Q(s.left, s.minLeft), s.maxLeft), s.oldTop = s.top = K(Q(s.top, s.minTop), s.maxTop), this.$canvas.css({
                width: s.width,
                height: s.height,
                left: s.left,
                top: s.top
            }), this.renderImage(), this.isCropped && this.isLimited && this.limitCropBox(!0, !0), t && this.output()
        }, renderImage: function (t) {
            var i, e = this.canvas, s = this.image;
            s.rotate && (i = dt({
                width: e.width,
                height: e.height,
                degree: s.rotate,
                aspectRatio: s.aspectRatio
            }, !0)), x.extend(s, i ? {
                width: i.width,
                height: i.height,
                left: (e.width - i.width) / 2,
                top: (e.height - i.height) / 2
            } : {width: e.width, height: e.height, left: 0, top: 0}), this.$clone.css({
                width: s.width,
                height: s.height,
                marginLeft: s.left,
                marginTop: s.top,
                transform: pt(s)
            }), t && this.output()
        }, initCropBox: function () {
            var t = this.options, i = this.canvas, e = t.aspectRatio, s = Z(t.autoCropArea) || .8,
                a = {width: i.width, height: i.height};
            e && (i.height * e > i.width ? a.height = a.width / e : a.width = a.height * e), this.cropBox = a, this.limitCropBox(!0, !0), a.width = K(Q(a.width, a.minWidth), a.maxWidth), a.height = K(Q(a.height, a.minHeight), a.maxHeight), a.width = Q(a.minWidth, a.width * s), a.height = Q(a.minHeight, a.height * s), a.oldLeft = a.left = i.left + (i.width - a.width) / 2, a.oldTop = a.top = i.top + (i.height - a.height) / 2, this.initialCropBox = x.extend({}, a)
        }, limitCropBox: function (t, i) {
            var e, s, a, o, h = this.options, n = h.aspectRatio, r = this.container, l = r.width, c = r.height,
                p = this.canvas, d = this.cropBox, g = this.isLimited;
            t && (e = Z(h.minCropBoxWidth) || 0, s = Z(h.minCropBoxHeight) || 0, e = K(e, l), s = K(s, c), a = K(l, g ? p.width : l), o = K(c, g ? p.height : c), n && (e && s ? e < s * n ? s = e / n : e = s * n : e ? s = e / n : s && (e = s * n), a < o * n ? o = a / n : a = o * n), d.minWidth = K(e, a), d.minHeight = K(s, o), d.maxWidth = a, d.maxHeight = o), i && (g ? (d.minLeft = Q(0, p.left), d.minTop = Q(0, p.top), d.maxLeft = K(l, p.left + p.width) - d.width, d.maxTop = K(c, p.top + p.height) - d.height) : (d.minLeft = 0, d.minTop = 0, d.maxLeft = l - d.width, d.maxTop = c - d.height))
        }, renderCropBox: function () {
            var t = this.options, i = this.container, e = i.width, s = i.height, a = this.cropBox;
            (a.width > a.maxWidth || a.width < a.minWidth) && (a.left = a.oldLeft), (a.height > a.maxHeight || a.height < a.minHeight) && (a.top = a.oldTop), a.width = K(Q(a.width, a.minWidth), a.maxWidth), a.height = K(Q(a.height, a.minHeight), a.maxHeight), this.limitCropBox(!1, !0), a.oldLeft = a.left = K(Q(a.left, a.minLeft), a.maxLeft), a.oldTop = a.top = K(Q(a.top, a.minTop), a.maxTop), t.movable && t.cropBoxMovable && this.$face.data(E, a.width === e && a.height === s ? S : j), this.$cropBox.css({
                width: a.width,
                height: a.height,
                left: a.left,
                top: a.top
            }), this.isCropped && this.isLimited && this.limitCanvas(!0, !0), this.isDisabled || this.output()
        }, output: function () {
            this.preview(), this.isCompleted ? this.trigger(Y, this.getData()) : this.isBuilt || this.$element.one(k, x.proxy(function () {
                this.trigger(Y, this.getData())
            }, this))
        }, initPreview: function () {
            var t, i = ct(this.crossOrigin), e = i ? this.crossOriginUrl : this.url;
            this.$preview = x(this.options.preview), this.$clone2 = t = x("<img" + i + ' src="' + e + '">'), this.$viewBox.html(t), this.$preview.each(function () {
                var t = x(this);
                t.data(O, {
                    width: t.width(),
                    height: t.height(),
                    html: t.html()
                }), t.html("<img" + i + ' src="' + e + '" style="display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;">')
            })
        }, resetPreview: function () {
            this.$preview.each(function () {
                var t = x(this), i = t.data(O);
                t.css({width: i.width, height: i.height}).html(i.html).removeData(O)
            })
        }, preview: function () {
            var n = this.image, t = this.canvas, i = this.cropBox, r = i.width, l = i.height, c = n.width, p = n.height,
                d = i.left - t.left - n.left, g = i.top - t.top - n.top;
            this.isCropped && !this.isDisabled && (this.$clone2.css({
                width: c,
                height: p,
                marginLeft: -d,
                marginTop: -g,
                transform: pt(n)
            }), this.$preview.each(function () {
                var t = x(this), i = t.data(O), e = i.width, s = i.height, a = e, o = s, h = 1;
                r && (o = l * (h = e / r)), l && s < o && (a = r * (h = s / l), o = s), t.css({
                    width: a,
                    height: o
                }).find("img").css({
                    width: c * h,
                    height: p * h,
                    marginLeft: -d * h,
                    marginTop: -g * h,
                    transform: pt(n)
                })
            }))
        }, bind: function () {
            var t = this.options, i = this.$element, e = this.$cropper;
            x.isFunction(t.cropstart) && i.on(T, t.cropstart), x.isFunction(t.cropmove) && i.on(L, t.cropmove), x.isFunction(t.cropend) && i.on(X, t.cropend), x.isFunction(t.crop) && i.on(Y, t.crop), x.isFunction(t.zoom) && i.on(M, t.zoom), e.on(f, x.proxy(this.cropStart, this)), t.zoomable && t.zoomOnWheel && e.on(w, x.proxy(this.wheel, this)), t.toggleDragModeOnDblclick && e.on(b, x.proxy(this.dblclick, this)), a.on(m, this._cropMove = nt(this.cropMove, this)).on(v, this._cropEnd = nt(this.cropEnd, this)), t.responsive && s.on(y, this._resize = nt(this.resize, this))
        }, unbind: function () {
            var t = this.options, i = this.$element, e = this.$cropper;
            x.isFunction(t.cropstart) && i.off(T, t.cropstart), x.isFunction(t.cropmove) && i.off(L, t.cropmove), x.isFunction(t.cropend) && i.off(X, t.cropend), x.isFunction(t.crop) && i.off(Y, t.crop), x.isFunction(t.zoom) && i.off(M, t.zoom), e.off(f, this.cropStart), t.zoomable && t.zoomOnWheel && e.off(w, this.wheel), t.toggleDragModeOnDblclick && e.off(b, this.dblclick), a.off(m, this._cropMove).off(v, this._cropEnd), t.responsive && s.off(y, this._resize)
        }, resize: function () {
            var e, s, a, t = this.options.restore, i = this.$container, o = this.container;
            !this.isDisabled && o && (1 == (a = i.width() / o.width) && i.height() === o.height || (t && (e = this.getCanvasData(), s = this.getCropBoxData()), this.render(), t && (this.setCanvasData(x.each(e, function (t, i) {
                e[t] = i * a
            })), this.setCropBoxData(x.each(s, function (t, i) {
                s[t] = i * a
            })))))
        }, dblclick: function () {
            this.isDisabled || this.$dragBox.hasClass(u) && this.setDragMode(S)
        }, wheel: function (t) {
            var i = t.originalEvent || t, e = Z(this.options.wheelZoomRatio) || .1, s = 1;
            this.isDisabled || (t.preventDefault(), this.wheeling || (this.wheeling = !0, setTimeout(x.proxy(function () {
                this.wheeling = !1
            }, this), 50), i.deltaY ? s = 0 < i.deltaY ? 1 : -1 : i.wheelDelta ? s = -i.wheelDelta / 120 : i.detail && (s = 0 < i.detail ? 1 : -1), o = -s * e, this.zoom(-s * e, t)))
        }, getRealzoom: function () {
            return o
        }, cropStart: function (t) {
            var i, e, s = this.options, a = t.originalEvent, o = a && a.touches, h = t;
            if (!this.isDisabled) {
                if (o) {
                    if (1 < (i = o.length)) {
                        if (!s.zoomable || !s.zoomOnTouch || 2 !== i) return;
                        h = o[1], this.startX2 = h.pageX, this.startY2 = h.pageY, e = N
                    }
                    h = o[0]
                }
                if (e = e || x(h.target).data(E), W.test(e)) {
                    if (this.trigger(T, {originalEvent: a, action: e}).isDefaultPrevented()) return;
                    t.preventDefault(), this.action = e, this.cropping = !1, this.startX = h.pageX || a && a.pageX, this.startY = h.pageY || a && a.pageY, e === A && (this.cropping = !0, this.$dragBox.addClass(p))
                }
            }
        }, cropMove: function (t) {
            var i, e = this.options, s = t.originalEvent, a = s && s.touches, o = t, h = this.action;
            if (!this.isDisabled) {
                if (a) {
                    if (1 < (i = a.length)) {
                        if (!e.zoomable || !e.zoomOnTouch || 2 !== i) return;
                        o = a[1], this.endX2 = o.pageX, this.endY2 = o.pageY
                    }
                    o = a[0]
                }
                if (h) {
                    if (this.trigger(L, {originalEvent: s, action: h}).isDefaultPrevented()) return;
                    t.preventDefault(), this.endX = o.pageX || s && s.pageX, this.endY = o.pageY || s && s.pageY, this.change(o.shiftKey, h === N ? t : null)
                }
            }
        }, cropEnd: function (t) {
            var i = t.originalEvent, e = this.action;
            this.isDisabled || e && (t.preventDefault(), this.cropping && (this.cropping = !1, this.$dragBox.toggleClass(p, this.isCropped && this.options.modal)), this.action = "", this.trigger(X, {
                originalEvent: i,
                action: e
            }))
        }, change: function (t, i) {
            var e, s, a, o, h, n, r, l = this.options.aspectRatio, c = this.action, p = this.container, d = this.canvas,
                g = this.cropBox, u = g.width, f = g.height, m = g.left, v = g.top, w = m + u, x = v + f, b = 0, C = 0,
                B = p.width, y = p.height, D = !0;
            switch (!l && t && (l = u && f ? u / f : 1), this.limited && (b = g.minLeft, C = g.minTop, B = b + K(p.width, d.left + d.width), y = C + K(p.height, d.top + d.height)), s = {
                x: this.endX - this.startX,
                y: this.endY - this.startY
            }, s, l && (s.X = s.y * l, s.Y = s.x / l), c) {
                case j:
                    m += s.x, v += s.y;
                    break;
                case"e":
                    if (0 <= s.x && (B <= w || l && (v <= C || y <= x))) {
                        D = !1;
                        break
                    }
                    u += s.x, l && (f = u / l, v -= s.Y / 2), u < 0 && (c = "w", u = 0);
                    break;
                case"n":
                    if (s.y <= 0 && (v <= C || l && (m <= b || B <= w))) {
                        D = !1;
                        break
                    }
                    f -= s.y, v += s.y, l && (u = f * l, m += s.X / 2), f < 0 && (c = "s", f = 0);
                    break;
                case"w":
                    if (s.x <= 0 && (m <= b || l && (v <= C || y <= x))) {
                        D = !1;
                        break
                    }
                    u -= s.x, m += s.x, l && (f = u / l, v += s.Y / 2), u < 0 && (c = "e", u = 0);
                    break;
                case"s":
                    if (0 <= s.y && (y <= x || l && (m <= b || B <= w))) {
                        D = !1;
                        break
                    }
                    f += s.y, l && (u = f * l, m -= s.X / 2), f < 0 && (c = "n", f = 0);
                    break;
                case I:
                    if (l) {
                        if (s.y <= 0 && (v <= C || B <= w)) {
                            D = !1;
                            break
                        }
                        f -= s.y, v += s.y, u = f * l
                    } else 0 <= s.x ? w < B ? u += s.x : s.y <= 0 && v <= C && (D = !1) : u += s.x, s.y <= 0 ? C < v && (f -= s.y, v += s.y) : (f -= s.y, v += s.y);
                    u < 0 && f < 0 ? (c = U, u = f = 0) : u < 0 ? (c = F, u = 0) : f < 0 && (c = P, f = 0);
                    break;
                case F:
                    if (l) {
                        if (s.y <= 0 && (v <= C || m <= b)) {
                            D = !1;
                            break
                        }
                        f -= s.y, v += s.y, u = f * l, m += s.X
                    } else s.x <= 0 ? b < m ? (u -= s.x, m += s.x) : s.y <= 0 && v <= C && (D = !1) : (u -= s.x, m += s.x), s.y <= 0 ? C < v && (f -= s.y, v += s.y) : (f -= s.y, v += s.y);
                    u < 0 && f < 0 ? (c = P, u = f = 0) : u < 0 ? (c = I, u = 0) : f < 0 && (c = U, f = 0);
                    break;
                case U:
                    if (l) {
                        if (s.x <= 0 && (m <= b || y <= x)) {
                            D = !1;
                            break
                        }
                        u -= s.x, m += s.x, f = u / l
                    } else s.x <= 0 ? b < m ? (u -= s.x, m += s.x) : 0 <= s.y && y <= x && (D = !1) : (u -= s.x, m += s.x), 0 <= s.y ? x < y && (f += s.y) : f += s.y;
                    u < 0 && f < 0 ? (c = I, u = f = 0) : u < 0 ? (c = P, u = 0) : f < 0 && (c = F, f = 0);
                    break;
                case P:
                    if (l) {
                        if (0 <= s.x && (B <= w || y <= x)) {
                            D = !1;
                            break
                        }
                        f = (u += s.x) / l
                    } else 0 <= s.x ? w < B ? u += s.x : 0 <= s.y && y <= x && (D = !1) : u += s.x, 0 <= s.y ? x < y && (f += s.y) : f += s.y;
                    u < 0 && f < 0 ? (c = F, u = f = 0) : u < 0 ? (c = U, u = 0) : f < 0 && (c = I, f = 0);
                    break;
                case S:
                    this.move(s.x, s.y), D = !1;
                    break;
                case N:
                    this.zoom((a = V(this.startX - this.startX2), o = V(this.startY - this.startY2), h = V(this.endX - this.endX2), n = V(this.endY - this.endY2), r = tt(a * a + o * o), (tt(h * h + n * n) - r) / r), i), this.startX2 = this.endX2, this.startY2 = this.endY2, D = !1;
                    break;
                case A:
                    if (!s.x || !s.y) {
                        D = !1;
                        break
                    }
                    e = this.$cropper.offset(), m = this.startX - e.left, v = this.startY - e.top, u = g.minWidth, f = g.minHeight, 0 < s.x ? c = 0 < s.y ? P : I : s.x < 0 && (m -= u, c = 0 < s.y ? U : F), s.y < 0 && (v -= f), this.isCropped || (this.$cropBox.removeClass($), this.isCropped = !0, this.limited && this.limitCropBox(!0, !0))
            }
            D && (g.width = u, g.height = f, g.left = m, g.top = v, this.action = c, this.renderCropBox()), this.startX = this.endX, this.startY = this.endY
        }, crop: function () {
            this.isBuilt && !this.isDisabled && (this.isCropped || (this.isCropped = !0, this.limitCropBox(!0, !0), this.options.modal && this.$dragBox.addClass(p), this.$cropBox.removeClass($)), this.setCropBoxData(this.initialCropBox))
        }, reset: function () {
            this.isBuilt && !this.isDisabled && (this.image = x.extend({}, this.initialImage), this.canvas = x.extend({}, this.initialCanvas), this.cropBox = x.extend({}, this.initialCropBox), this.renderCanvas(), this.isCropped && this.renderCropBox())
        }, clear: function () {
            this.isCropped && !this.isDisabled && (x.extend(this.cropBox, {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            }), this.isCropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), this.$dragBox.removeClass(p), this.$cropBox.addClass($))
        }, replace: function (t, i) {
            !this.isDisabled && t && (this.isImg && this.$element.attr("src", t), i ? (this.url = t, this.$clone.attr("src", t), this.isBuilt && this.$preview.find("img").add(this.$clone2).attr("src", t)) : (this.isImg && (this.isReplaced = !0), this.options.data = null, this.load(t)))
        }, enable: function () {
            this.isBuilt && (this.isDisabled = !1, this.$cropper.removeClass(i))
        }, disable: function () {
            this.isBuilt && (this.isDisabled = !0, this.$cropper.addClass(i))
        }, destroy: function () {
            var t = this.$element;
            this.isLoaded ? (this.isImg && this.isReplaced && t.attr("src", this.originalUrl), this.unbuild(), t.removeClass($)) : this.isImg ? t.off(C, this.start) : this.$clone && this.$clone.remove(), t.removeData(c)
        }, move: function (t, i) {
            var e = this.canvas;
            this.moveTo(ot(t) ? t : e.left + Z(t), ot(i) ? i : e.top + Z(i)), null != this.movecallback && this.movecallback(t, i, this.handler)
        }, moveTo: function (t, i) {
            var e = this.canvas, s = !1;
            ot(i) && (i = t), t = Z(t), i = Z(i), this.isBuilt && !this.isDisabled && this.options.movable && (at(t) && (e.left = t, s = !0), at(i) && (e.top = i, s = !0), s && this.renderCanvas(!0))
        }, zoom: function (t, i) {
            var e = this.canvas;
            t = (t = Z(t)) < 0 ? 1 / (1 - t) : 1 + t, this.zoomTo(e.width * t / e.naturalWidth, i)
        }, zoomTo: function (t, i) {
            var e, s, a, o, h, n = this.options, r = this.canvas, l = r.width, c = r.height, p = r.naturalWidth,
                d = r.naturalHeight;
            if (0 <= (t = Z(t)) && this.isBuilt && !this.isDisabled && n.zoomable) {
                if (s = p * t, a = d * t, i && (e = i.originalEvent), this.trigger(M, {
                    originalEvent: e,
                    oldRatio: l / p,
                    ratio: s / p
                }).isDefaultPrevented()) return;
                e ? (o = this.$cropper.offset(), h = e.touches ? function (t) {
                    var i = t.length, e = 0, s = 0;
                    return i && (x.each(t, function (t, i) {
                        e += i.pageX, s += i.pageY
                    }), e /= i, s /= i), {pageX: e, pageY: s}
                }(e.touches) : {
                    pageX: i.pageX || e.pageX || 0,
                    pageY: i.pageY || e.pageY || 0
                }, r.left -= (s - l) * ((h.pageX - o.left - r.left) / l), r.top -= (a - c) * ((h.pageY - o.top - r.top) / c)) : (r.left -= (s - l) / 2, r.top -= (a - c) / 2), null != this.zoomcallback && this.zoomcallback(t, r.left, r.top, this.handler), r.width = s, r.height = a, this.renderCanvas(!0)
            }
        }, rotate: function (t) {
            this.rotateTo((this.image.rotate || 0) + Z(t))
        }, rotateTo: function (t) {
            at(t = Z(t)) && this.isBuilt && !this.isDisabled && this.options.rotatable && (this.image.rotate = t % 360, this.isRotated = !0, this.renderCanvas(!0))
        }, scale: function (t, i) {
            var e = this.image, s = !1;
            ot(i) && (i = t), t = Z(t), i = Z(i), this.isBuilt && !this.isDisabled && this.options.scalable && (at(t) && (e.scaleX = t, s = !0), at(i) && (e.scaleY = i, s = !0), s && this.renderImage(!0))
        }, scaleX: function (t) {
            var i = this.image.scaleY;
            this.scale(t, at(i) ? i : 1)
        }, scaleY: function (t) {
            var i = this.image.scaleX;
            this.scale(at(i) ? i : 1, t)
        }, getData: function (e) {
            var s, a, t = this.options, i = this.image, o = this.canvas, h = this.cropBox;
            return this.isBuilt && this.isCropped ? (a = {
                x: h.left - o.left,
                y: h.top - o.top,
                width: h.width,
                height: h.height
            }, s = i.width / i.naturalWidth, x.each(a, function (t, i) {
                i /= s, a[t] = e ? it(i) : i
            })) : a = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, t.rotatable && (a.rotate = i.rotate || 0), t.scalable && (a.scaleX = i.scaleX || 1, a.scaleY = i.scaleY || 1), a
        }, setData: function (t) {
            var i, e, s, a = this.options, o = this.image, h = this.canvas, n = {};
            x.isFunction(t) && (t = t.call(this.element)), this.isBuilt && !this.isDisabled && x.isPlainObject(t) && (a.rotatable && at(t.rotate) && t.rotate !== o.rotate && (o.rotate = t.rotate, this.isRotated = i = !0), a.scalable && (at(t.scaleX) && t.scaleX !== o.scaleX && (o.scaleX = t.scaleX, e = !0), at(t.scaleY) && t.scaleY !== o.scaleY && (o.scaleY = t.scaleY, e = !0)), i ? this.renderCanvas() : e && this.renderImage(), s = o.width / o.naturalWidth, at(t.x) && (n.left = t.x * s + h.left), at(t.y) && (n.top = t.y * s + h.top), at(t.width) && (n.width = t.width * s), at(t.height) && (n.height = t.height * s), this.setCropBoxData(n))
        }, getContainerData: function () {
            return this.isBuilt ? this.container : {}
        }, getImageData: function () {
            return this.isLoaded ? this.image : {}
        }, getCanvasData: function () {
            var e = this.canvas, s = {};
            return this.isBuilt && x.each(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function (t, i) {
                s[i] = e[i]
            }), s
        }, setCanvasData: function (t) {
            var i = this.canvas, e = i.aspectRatio;
            x.isFunction(t) && (t = t.call(this.$element)), this.isBuilt && !this.isDisabled && x.isPlainObject(t) && (at(t.left) && (i.left = t.left), at(t.top) && (i.top = t.top), at(t.width) ? (i.width = t.width, i.height = t.width / e) : at(t.height) && (i.height = t.height, i.width = t.height * e), this.renderCanvas(!0))
        }, getCropBoxData: function () {
            var t, i = this.cropBox;
            return this.isBuilt && this.isCropped && (t = {
                left: i.left,
                top: i.top,
                width: i.width,
                height: i.height
            }), t || {}
        }, setCropBoxData: function (t) {
            var i, e, s = this.cropBox, a = this.options.aspectRatio;
            x.isFunction(t) && (t = t.call(this.$element)), this.isBuilt && this.isCropped && !this.isDisabled && x.isPlainObject(t) && (at(t.left) && (s.left = t.left), at(t.top) && (s.top = t.top), at(t.width) && (i = !0, s.width = t.width), at(t.height) && (e = !0, s.height = t.height), a && (i ? s.height = s.width / a : e && (s.width = s.height * a)), this.renderCropBox())
        }, getCroppedCanvas: function (t) {
            var g, u, i, e, s, a, f, o, h, n, m;
            if (this.isBuilt && _) return this.isCropped ? (x.isPlainObject(t) || (t = {}), m = this.getData(), g = m.width, u = m.height, o = g / u, x.isPlainObject(t) && (s = t.width, a = t.height, s ? (a = s / o, f = s / g) : a && (s = a * o, f = a / u)), i = et(s || g), e = et(a || u), (h = x("<canvas>")[0]).width = i, h.height = e, n = h.getContext("2d"), t.fillColor && (n.fillStyle = t.fillColor, n.fillRect(0, 0, i, e)), n.drawImage.apply(n, function () {
                var t, i, e, s, a, o, h = gt(this.$clone[0], this.image), n = h.width, r = h.height, l = this.canvas,
                    c = [h], p = m.x + l.naturalWidth * (V(m.scaleX || 1) - 1) / 2,
                    d = m.y + l.naturalHeight * (V(m.scaleY || 1) - 1) / 2;
                return p <= -g || n < p ? p = t = e = a = 0 : p <= 0 ? (e = -p, t = a = K(n, g + (p = 0))) : p <= n && (e = 0, t = a = K(g, n - p)), t <= 0 || d <= -u || r < d ? d = i = s = o = 0 : d <= 0 ? (s = -d, i = o = K(r, u + (d = 0))) : d <= r && (s = 0, i = o = K(u, r - d)), c.push(et(p), et(d), et(t), et(i)), f && (e *= f, s *= f, a *= f, o *= f), 0 < a && 0 < o && c.push(et(e), et(s), et(a), et(o)), c
            }.call(this)), h) : gt(this.$clone[0], this.image)
        }, setAspectRatio: function (t) {
            var i = this.options;
            this.isDisabled || ot(t) || (i.aspectRatio = Q(0, t) || NaN, this.isBuilt && (this.initCropBox(), this.isCropped && this.renderCropBox()))
        }, setDragMode: function (t) {
            var i, e, s = this.options;
            this.isLoaded && !this.isDisabled && (i = t === A, e = s.movable && t === S, t = i || e ? t : "none", this.$dragBox.data(E, t).toggleClass(u, i).toggleClass(g, e), s.cropBoxMovable || this.$face.data(E, t).toggleClass(u, i).toggleClass(g, e))
        }, updateCallback: function (t, i, e) {
            this.zoomcallback = t, this.movecallback = i, this.handler = e
        }, getZoomback: function () {
            return this.zoomback
        }, getMoveback: function () {
            return this.moveback
        }, gethandler: function () {
            return this
        }, moveback: function (t, i, e) {
            var s = e.canvas;
            e.moveTo(ot(t) ? t : s.left + Z(t), ot(i) ? i : s.top + Z(i))
        }, zoomback: function (t, i, e, s) {
            var a, o, h = s.options, n = s.canvas, r = (n.width, n.height, n.naturalWidth), l = n.naturalHeight;
            0 <= (t = Z(t)) && s.isBuilt && !s.isDisabled && h.zoomable && (a = r * t, o = l * t, n.left = i, n.top = e, n.width = a, n.height = o, s.renderCanvas(!0))
        }
    }, ft.DEFAULTS = {
        viewMode: 0,
        dragMode: "crop",
        aspectRatio: NaN,
        data: null,
        preview: "",
        responsive: !0,
        restore: !0,
        checkCrossOrigin: !0,
        checkOrientation: !0,
        modal: !0,
        guides: !0,
        center: !0,
        highlight: !0,
        background: !0,
        autoCrop: !0,
        autoCropArea: .8,
        movable: !0,
        rotatable: !0,
        scalable: !0,
        zoomable: !0,
        zoomOnTouch: !0,
        zoomOnWheel: !0,
        wheelZoomRatio: .1,
        cropBoxMovable: !0,
        cropBoxResizable: !0,
        toggleDragModeOnDblclick: !0,
        minCanvasWidth: 0,
        minCanvasHeight: 0,
        minCropBoxWidth: 0,
        minCropBoxHeight: 0,
        minContainerWidth: 200,
        minContainerHeight: 100,
        build: null,
        built: null,
        cropstart: null,
        cropmove: null,
        cropend: null,
        crop: null,
        zoom: null
    }, ft.setDefaults = function (t) {
        x.extend(ft.DEFAULTS, t)
    }, ft.TEMPLATE = '<div class="cropper-container"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-action="e"></span><span class="cropper-line line-n" data-action="n"></span><span class="cropper-line line-w" data-action="w"></span><span class="cropper-line line-s" data-action="s"></span><span class="cropper-point point-e" data-action="e"></span><span class="cropper-point point-n" data-action="n"></span><span class="cropper-point point-w" data-action="w"></span><span class="cropper-point point-s" data-action="s"></span><span class="cropper-point point-ne" data-action="ne"></span><span class="cropper-point point-nw" data-action="nw"></span><span class="cropper-point point-sw" data-action="sw"></span><span class="cropper-point point-se" data-action="se"></span></div></div>', ft.other = x.fn.cropper, x.fn.cropper = function (a) {
        var o, h = ht(arguments, 1);
        return this.each(function () {
            var t, i, e = x(this), s = e.data(c);
            if (!s) {
                if (/destroy/.test(a)) return;
                t = x.extend({}, e.data(), x.isPlainObject(a) && a), e.data(c, s = new ft(this, t))
            }
            "string" == typeof a && x.isFunction(i = s[a]) && (o = i.apply(s, h))
        }), ot(o) ? this : o
    }, x.fn.cropper.Constructor = ft, x.fn.cropper.setDefaults = ft.setDefaults, x.fn.cropper.noConflict = function () {
        return x.fn.cropper = ft.other, this
    }
});